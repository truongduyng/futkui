import { useCallback } from 'react';
import { id } from '@instantdb/react-native';
import { instantClient } from './instantClient';

export function useMatchOperations() {
  const db = instantClient;

  const createMatch = useCallback(
    async (matchData: {
      groupId: string;
      title: string;
      description: string;
      gameType: string;
      location: string;
      matchDate: number;
      creatorId: string;
      authorName: string;
    }, triggerGroupNotifications: (data: any) => Promise<void>) => {
      const matchId = id();
      const messageId = id();

      const result = await db.transact([
        db.tx.matches[matchId].update({
          title: matchData.title,
          description: matchData.description,
          gameType: matchData.gameType,
          location: matchData.location,
          matchDate: matchData.matchDate,
          createdAt: Date.now(),
          isActive: true,
        }).link({
          group: matchData.groupId,
          creator: matchData.creatorId,
          message: messageId,
        }),
        db.tx.messages[messageId].update({
          content: ``,
          authorName: matchData.authorName,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          type: 'match',
        }).link({
          group: matchData.groupId,
          author: matchData.creatorId,
        }),
      ]);

      // Trigger notifications after successful match creation
      try {
        await triggerGroupNotifications({
          groupId: matchData.groupId,
          messageContent: '', // Will be generated by notification system
          authorName: matchData.authorName,
          authorId: matchData.creatorId,
          mentions: [],
          messageId: messageId,
          messageType: 'match',
          matchData: {
            description: matchData.description,
          },
        });
      } catch (error) {
        console.error('Failed to send match notifications:', error);
        // Don't throw error for notifications as match was already created successfully
      }

      return result;
    },
    [db]
  );

  const rsvpToMatch = useCallback(
    async (rsvpData: {
      matchId: string;
      userId: string;
      response: 'yes' | 'no' | 'maybe';
      existingRsvps: any[];
    }) => {
      const existingRsvp = rsvpData.existingRsvps.find(
        (rsvp: any) => rsvp.user?.id === rsvpData.userId
      );

      if (existingRsvp) {
        // Update existing RSVP
        const result = await db.transact([
          db.tx.rsvps[existingRsvp.id].update({
            response: rsvpData.response,
            updatedAt: Date.now(),
          }),
        ]);
        return result;
      } else {
        // Create new RSVP
        const result = await db.transact([
          db.tx.rsvps[id()].update({
            response: rsvpData.response,
            createdAt: Date.now(),
            updatedAt: Date.now(),
          }).link({
            match: rsvpData.matchId,
            user: rsvpData.userId,
          }),
        ]);
        return result;
      }
    },
    [db]
  );

  const checkInToMatch = useCallback(
    async (checkInData: {
      matchId: string;
      userId: string;
    }) => {
      const result = await db.transact([
        db.tx.checkIns[id()].update({
          checkedInAt: Date.now(),
        }).link({
          match: checkInData.matchId,
          user: checkInData.userId,
        }),
      ]);

      return result;
    },
    [db]
  );

  const unCheckInFromMatch = useCallback(
    async (unCheckInData: {
      matchId: string;
      userId: string;
      existingCheckIns: any[];
    }) => {
      // Find the checkIn entry for this user
      const existingCheckIn = unCheckInData.existingCheckIns.find(
        (checkIn: any) => checkIn.user?.id === unCheckInData.userId
      );

      if (existingCheckIn) {
        const result = await db.transact([
          db.tx.checkIns[existingCheckIn.id].delete(),
        ]);
        return result;
      }

      return null;
    },
    [db]
  );

  const closeMatch = useCallback(
    async (matchId: string) => {
      const result = await db.transact([
        db.tx.matches[matchId].update({
          closedAt: Date.now(),
          isActive: false,
        }),
      ]);
      return result;
    },
    [db]
  );

  const addExpense = useCallback(
    async (expenseData: {
      matchId: string;
      amount: number;
      billImageUrl?: string | null;
      note?: string;
      creatorId: string;
    }) => {
      const ledgerEntryId = id();
      const profileRefKey = `${expenseData.creatorId}_${expenseData.matchId}`;

      const result = await db.transact([
        db.tx.ledgerEntries[ledgerEntryId].update({
          refId: expenseData.matchId,
          amount: expenseData.amount,
          type: 'match_expense',
          billImageUrl: expenseData.billImageUrl,
          note: expenseData.note,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          profileRefKey: profileRefKey,
        }).link({
          profile: expenseData.creatorId,
        }),
      ]);

      return result;
    },
    [db]
  );

  const editExpense = useCallback(
    async (expenseData: {
      expenseId: string;
      amount: number;
      billImageUrl?: string | null;
      note?: string;
    }) => {
      const result = await db.transact([
        db.tx.ledgerEntries[expenseData.expenseId].update({
          amount: expenseData.amount,
          billImageUrl: expenseData.billImageUrl,
          note: expenseData.note,
          updatedAt: Date.now(),
        }),
      ]);

      return result;
    },
    [db]
  );

  return {
    createMatch,
    rsvpToMatch,
    checkInToMatch,
    unCheckInFromMatch,
    closeMatch,
    addExpense,
    editExpense,
  };
}